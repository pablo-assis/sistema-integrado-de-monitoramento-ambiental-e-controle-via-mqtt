#include "ssd1306.h"
#include "pico/stdlib.h"
#include "hardware/i2c.h"

#define SSD1306_WIDTH 128
#define SSD1306_HEIGHT 64

static i2c_inst_t *g_i2c = NULL;
static uint8_t g_addr = 0x3C; // padrão
static uint8_t fb[SSD1306_WIDTH * SSD1306_HEIGHT / 8];

static inline int clamp(int v, int lo, int hi) { return v < lo ? lo : (v > hi ? hi : v); }

static void ssd1306_write_cmd(uint8_t cmd) {
    uint8_t buf[2] = {0x00, cmd};
    i2c_write_blocking(g_i2c, g_addr, buf, 2, false);
}

static void ssd1306_write_data(const uint8_t *data, size_t len) {
    // Envia em blocos com control byte 0x40
    const size_t chunk = 16;
    uint8_t out[1 + chunk];
    out[0] = 0x40;
    while (len) {
        size_t n = len > chunk ? chunk : len;
        for (size_t i = 0; i < n; ++i) out[1 + i] = data[i];
        i2c_write_blocking(g_i2c, g_addr, out, 1 + n, false);
        data += n;
        len -= n;
    }
}

bool ssd1306_init(i2c_inst_t *i2c, uint8_t addr) {
    g_i2c = i2c;
    g_addr = addr;

    // Init sequence (internal VCC, horizontal addressing)
    ssd1306_write_cmd(0xAE); // display off
    ssd1306_write_cmd(0xD5); ssd1306_write_cmd(0x80); // clock
    ssd1306_write_cmd(0xA8); ssd1306_write_cmd(0x3F); // multiplex 1/64
    ssd1306_write_cmd(0xD3); ssd1306_write_cmd(0x00); // display offset
    ssd1306_write_cmd(0x40); // start line = 0
    ssd1306_write_cmd(0x8D); ssd1306_write_cmd(0x14); // charge pump on
    ssd1306_write_cmd(0x20); ssd1306_write_cmd(0x00); // memory mode horizontal
    ssd1306_write_cmd(0xA1); // segment remap
    ssd1306_write_cmd(0xC8); // COM scan dec
    ssd1306_write_cmd(0xDA); ssd1306_write_cmd(0x12); // compins
    ssd1306_write_cmd(0x81); ssd1306_write_cmd(0xCF); // contrast
    ssd1306_write_cmd(0xD9); ssd1306_write_cmd(0xF1); // precharge
    ssd1306_write_cmd(0xDB); ssd1306_write_cmd(0x40); // vcom detect
    ssd1306_write_cmd(0xA4); // resume RAM
    ssd1306_write_cmd(0xA6); // normal display
    ssd1306_write_cmd(0x2E); // deactivate scroll

    // set column/page range
    ssd1306_write_cmd(0x21); ssd1306_write_cmd(0x00); ssd1306_write_cmd(SSD1306_WIDTH - 1);
    ssd1306_write_cmd(0x22); ssd1306_write_cmd(0x00); ssd1306_write_cmd((SSD1306_HEIGHT/8) - 1);

    ssd1306_clear();
    ssd1306_update();
    ssd1306_write_cmd(0xAF); // display on
    return true;
}

void ssd1306_clear(void) {
    for (size_t i = 0; i < sizeof(fb); ++i) fb[i] = 0x00;
}

void ssd1306_update(void) {
    ssd1306_write_cmd(0x21); ssd1306_write_cmd(0x00); ssd1306_write_cmd(SSD1306_WIDTH - 1);
    ssd1306_write_cmd(0x22); ssd1306_write_cmd(0x00); ssd1306_write_cmd((SSD1306_HEIGHT/8) - 1);
    ssd1306_write_data(fb, sizeof(fb));
}

void ssd1306_set_pixel(int x, int y, bool on) {
    if (x < 0 || x >= SSD1306_WIDTH || y < 0 || y >= SSD1306_HEIGHT) return;
    int page = y >> 3;
    int bit = y & 7;
    size_t idx = page * SSD1306_WIDTH + x;
    if (on) fb[idx] |= (1u << bit); else fb[idx] &= ~(1u << bit);
}

void ssd1306_draw_line(int x0, int y0, int x1, int y1, bool on) {
    int dx = (x1 > x0) ? (x1 - x0) : (x0 - x1);
    int sx = (x0 < x1) ? 1 : -1;
    int dy = -((y1 > y0) ? (y1 - y0) : (y0 - y1));
    int sy = (y0 < y1) ? 1 : -1;
    int err = dx + dy;
    while (true) {
        ssd1306_set_pixel(x0, y0, on);
        if (x0 == x1 && y0 == y1) break;
        int e2 = 2 * err;
        if (e2 >= dy) { err += dy; x0 += sx; }
        if (e2 <= dx) { err += dx; y0 += sy; }
    }
}

void ssd1306_draw_circle(int cx, int cy, int r, bool on) {
    int x = r, y = 0;
    int err = 0;
    while (x >= y) {
        ssd1306_set_pixel(cx + x, cy + y, on);
        ssd1306_set_pixel(cx + y, cy + x, on);
        ssd1306_set_pixel(cx - y, cy + x, on);
        ssd1306_set_pixel(cx - x, cy + y, on);
        ssd1306_set_pixel(cx - x, cy - y, on);
        ssd1306_set_pixel(cx - y, cy - x, on);
        ssd1306_set_pixel(cx + y, cy - x, on);
        ssd1306_set_pixel(cx + x, cy - y, on);
        y++;
        if (err <= 0) { err += 2*y + 1; } else { x--; err -= 2*x + 1; }
    }
}

// Desenha bitmap monocromático: bytes em ordem horizontal, 8 pixels por byte (MSB primeiro)
void ssd1306_draw_bitmap(int x, int y, const uint8_t *bmp, int w, int h, bool white) {
    if (!bmp || w <= 0 || h <= 0) return;
    int x0 = x;
    int y0 = y;
    int bytes_per_row = (w + 7) / 8;
    for (int row = 0; row < h; ++row) {
        const uint8_t *row_ptr = bmp + row * bytes_per_row;
        for (int col = 0; col < w; ++col) {
            int byte_index = col >> 3;             // col / 8
            int bit_index = 7 - (col & 7);         // MSB primeiro
            uint8_t b = row_ptr[byte_index];
            bool on = ((b >> bit_index) & 0x1) ? white : !white;
            ssd1306_set_pixel(x0 + col, y0 + row, on);
        }
    }
}

// Fonte 5x7 ASCII (0x20..0x7F), cada caractere em 5 colunas, LSB para cima em cada byte
// Fonte padrão compacta (inspirada em classic 5x7). Apenas caracteres comuns.
static const uint8_t font5x7[96][5] = {
    // 0x20 ' '
    {0x00,0x00,0x00,0x00,0x00},
    // 0x21 '!'
    {0x00,0x00,0x5F,0x00,0x00},
    // 0x22 '"'
    {0x00,0x07,0x00,0x07,0x00},
    // 0x23 '#'
    {0x14,0x7F,0x14,0x7F,0x14},
    // 0x24 '$'
    {0x24,0x2A,0x7F,0x2A,0x12},
    // 0x25 '%'
    {0x23,0x13,0x08,0x64,0x62},
    // 0x26 '&'
    {0x36,0x49,0x55,0x22,0x50},
    // 0x27 '\''
    {0x00,0x05,0x03,0x00,0x00},
    // 0x28 '('
    {0x00,0x1C,0x22,0x41,0x00},
    // 0x29 ')'
    {0x00,0x41,0x22,0x1C,0x00},
    // 0x2A '*'
    {0x14,0x08,0x3E,0x08,0x14},
    // 0x2B '+'
    {0x08,0x08,0x3E,0x08,0x08},
    // 0x2C ','
    {0x00,0x50,0x30,0x00,0x00},
    // 0x2D '-'
    {0x08,0x08,0x08,0x08,0x08},
    // 0x2E '.'
    {0x00,0x60,0x60,0x00,0x00},
    // 0x2F '/'
    {0x20,0x10,0x08,0x04,0x02},
    // 0x30 '0'
    {0x3E,0x51,0x49,0x45,0x3E},
    // 0x31 '1'
    {0x00,0x42,0x7F,0x40,0x00},
    // 0x32 '2'
    {0x42,0x61,0x51,0x49,0x46},
    // 0x33 '3'
    {0x21,0x41,0x45,0x4B,0x31},
    // 0x34 '4'
    {0x18,0x14,0x12,0x7F,0x10},
    // 0x35 '5'
    {0x27,0x45,0x45,0x45,0x39},
    // 0x36 '6'
    {0x3C,0x4A,0x49,0x49,0x30},
    // 0x37 '7'
    {0x01,0x71,0x09,0x05,0x03},
    // 0x38 '8'
    {0x36,0x49,0x49,0x49,0x36},
    // 0x39 '9'
    {0x06,0x49,0x49,0x29,0x1E},
    // 0x3A ':'
    {0x00,0x36,0x36,0x00,0x00},
    // 0x3B ';'
    {0x00,0x56,0x36,0x00,0x00},
    // 0x3C '<'
    {0x08,0x14,0x22,0x41,0x00},
    // 0x3D '='
    {0x14,0x14,0x14,0x14,0x14},
    // 0x3E '>'
    {0x00,0x41,0x22,0x14,0x08},
    // 0x3F '?'
    {0x02,0x01,0x51,0x09,0x06},
    // 0x40 '@'
    {0x32,0x49,0x79,0x41,0x3E},
    // 0x41 'A'
    {0x7E,0x11,0x11,0x11,0x7E},
    // 0x42 'B'
    {0x7F,0x49,0x49,0x49,0x36},
    // 0x43 'C'
    {0x3E,0x41,0x41,0x41,0x22},
    // 0x44 'D'
    {0x7F,0x41,0x41,0x22,0x1C},
    // 0x45 'E'
    {0x7F,0x49,0x49,0x49,0x41},
    // 0x46 'F'
    {0x7F,0x09,0x09,0x09,0x01},
    // 0x47 'G'
    {0x3E,0x41,0x49,0x49,0x7A},
    // 0x48 'H'
    {0x7F,0x08,0x08,0x08,0x7F},
    // 0x49 'I'
    {0x00,0x41,0x7F,0x41,0x00},
    // 0x4A 'J'
    {0x20,0x40,0x41,0x3F,0x01},
    // 0x4B 'K'
    {0x7F,0x08,0x14,0x22,0x41},
    // 0x4C 'L'
    {0x7F,0x40,0x40,0x40,0x40},
    // 0x4D 'M'
    {0x7F,0x02,0x0C,0x02,0x7F},
    // 0x4E 'N'
    {0x7F,0x04,0x08,0x10,0x7F},
    // 0x4F 'O'
    {0x3E,0x41,0x41,0x41,0x3E},
    // 0x50 'P'
    {0x7F,0x09,0x09,0x09,0x06},
    // 0x51 'Q'
    {0x3E,0x41,0x51,0x21,0x5E},
    // 0x52 'R'
    {0x7F,0x09,0x19,0x29,0x46},
    // 0x53 'S'
    {0x46,0x49,0x49,0x49,0x31},
    // 0x54 'T'
    {0x01,0x01,0x7F,0x01,0x01},
    // 0x55 'U'
    {0x3F,0x40,0x40,0x40,0x3F},
    // 0x56 'V'
    {0x1F,0x20,0x40,0x20,0x1F},
    // 0x57 'W'
    {0x7F,0x20,0x18,0x20,0x7F},
    // 0x58 'X'
    {0x63,0x14,0x08,0x14,0x63},
    // 0x59 'Y'
    {0x03,0x04,0x78,0x04,0x03},
    // 0x5A 'Z'
    {0x61,0x51,0x49,0x45,0x43},
    // 0x5B '['
    {0x00,0x7F,0x41,0x41,0x00},
    // 0x5C '\\'
    {0x02,0x04,0x08,0x10,0x20},
    // 0x5D ']'
    {0x00,0x41,0x41,0x7F,0x00},
    // 0x5E '^'
    {0x04,0x02,0x01,0x02,0x04},
    // 0x5F '_'
    {0x40,0x40,0x40,0x40,0x40},
    // 0x60 '`'
    {0x00,0x01,0x02,0x00,0x00},
    // 0x61 'a'
    {0x20,0x54,0x54,0x54,0x78},
    // 0x62 'b'
    {0x7F,0x48,0x44,0x44,0x38},
    // 0x63 'c'
    {0x38,0x44,0x44,0x44,0x20},
    // 0x64 'd'
    {0x38,0x44,0x44,0x48,0x7F},
    // 0x65 'e'
    {0x38,0x54,0x54,0x54,0x18},
    // 0x66 'f'
    {0x08,0x7E,0x09,0x01,0x02},
    // 0x67 'g'
    {0x0C,0x52,0x52,0x52,0x3E},
    // 0x68 'h'
    {0x7F,0x08,0x04,0x04,0x78},
    // 0x69 'i'
    {0x00,0x44,0x7D,0x40,0x00},
    // 0x6A 'j'
    {0x20,0x40,0x44,0x3D,0x00},
    // 0x6B 'k'
    {0x7F,0x10,0x28,0x44,0x00},
    // 0x6C 'l'
    {0x00,0x41,0x7F,0x40,0x00},
    // 0x6D 'm'
    {0x7C,0x04,0x18,0x04,0x78},
    // 0x6E 'n'
    {0x7C,0x08,0x04,0x04,0x78},
    // 0x6F 'o'
    {0x38,0x44,0x44,0x44,0x38},
    // 0x70 'p'
    {0x7C,0x14,0x14,0x14,0x08},
    // 0x71 'q'
    {0x08,0x14,0x14,0x14,0x7C},
    // 0x72 'r'
    {0x7C,0x08,0x04,0x04,0x08},
    // 0x73 's'
    {0x48,0x54,0x54,0x54,0x20},
    // 0x74 't'
    {0x04,0x3F,0x44,0x40,0x20},
    // 0x75 'u'
    {0x3C,0x40,0x40,0x20,0x7C},
    // 0x76 'v'
    {0x1C,0x20,0x40,0x20,0x1C},
    // 0x77 'w'
    {0x3C,0x40,0x30,0x40,0x3C},
    // 0x78 'x'
    {0x44,0x28,0x10,0x28,0x44},
    // 0x79 'y'
    {0x0C,0x50,0x50,0x50,0x3C},
    // 0x7A 'z'
    {0x44,0x64,0x54,0x4C,0x44},
    // 0x7B '{'
    {0x00,0x08,0x36,0x41,0x00},
    // 0x7C '|'
    {0x00,0x00,0x7F,0x00,0x00},
    // 0x7D '}'
    {0x00,0x41,0x36,0x08,0x00},
    // 0x7E '~'
    {0x08,0x08,0x2A,0x1C,0x08},
    // 0x7F (DEL -> vazio)
    {0x00,0x00,0x00,0x00,0x00}
};

void ssd1306_draw_char(int x, int y, char c, bool white) {
    if (c < 0x20 || c > 0x7F) c = '?';
    const uint8_t *glyph = font5x7[c - 0x20];
    for (int col = 0; col < 5; ++col) {
        uint8_t bits = glyph[col];
        for (int row = 0; row < 7; ++row) {
            bool on = (bits >> row) & 0x01; // LSB = topo da letra
            ssd1306_set_pixel(x + col, y + row, white ? on : !on);
        }
    }
}

void ssd1306_draw_text(int x, int y, const char *text, bool white) {
    int cx = x;
    int cy = y;
    for (const char *p = text; *p; ++p) {
        if (*p == '\n') { cy += 8; cx = x; continue; }
        if (cx + 5 >= SSD1306_WIDTH) { cy += 8; cx = x; }
        if (cy + 7 >= SSD1306_HEIGHT) break;
        ssd1306_draw_char(cx, cy, *p, white);
        cx += 6; // 5 colunas + 1 espaçamento
    }
}

void ssd1306_draw_char_scaled(int x, int y, char c, int scale, bool white) {
    if (scale < 1) scale = 1;
    if (c < 0x20 || c > 0x7F) c = '?';
    const uint8_t *glyph = font5x7[c - 0x20];
    for (int col = 0; col < 5; ++col) {
        uint8_t bits = glyph[col];
        for (int row = 0; row < 7; ++row) {
            bool on = (bits >> row) & 0x01;
            if (!on) continue;
            // desenha bloco scale x scale
            for (int dx = 0; dx < scale; ++dx) {
                for (int dy = 0; dy < scale; ++dy) {
                    ssd1306_set_pixel(x + col*scale + dx, y + row*scale + dy, white);
                }
            }
        }
    }
}

void ssd1306_draw_text_scaled(int x, int y, const char *text, int scale, bool white) {
    if (scale < 1) scale = 1;
    int cx = x;
    int cy = y;
    for (const char *p = text; *p; ++p) {
        if (*p == '\n') { cy += (7 + 1) * scale; cx = x; continue; }
        if (cx + 5*scale >= SSD1306_WIDTH) { cy += (7 + 1) * scale; cx = x; }
        if (cy + 7*scale >= SSD1306_HEIGHT) break;
        ssd1306_draw_char_scaled(cx, cy, *p, scale, white);
        cx += 6 * scale; // 5 colunas + 1 espaçamento, escalado
    }
}
