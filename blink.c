#include <stdio.h>
#include <string.h>
#include "main.h"
#include "pico/stdlib.h"
#include "pico/cyw43_arch.h"
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"
#include "queue.h"
#include "hardware/i2c.h"
#include "hardware/adc.h"
#include "hardware/pwm.h"
#include "inc/bmp280.h"
#include "inc/ssd1306.h"
#include "inc/vl53l1x.h"
#include "inc/vl53l0x.h"
#include <stdint.h>

// Compatibilidade com arrays gerados para Arduino
#ifndef PROGMEM
#define PROGMEM
#endif
#include "pico/stdio_usb.h"

// --- Definições de Hardware ---
#define I2C_ADDR 0x76 // Endereço padrão do BMP280
#define I2C_SDA_PIN 0 // Pino SDA (GP0)
#define I2C_SCL_PIN 1 // Pino SCL (GP1)

// Display SSD1306 em I2C1 (GP14=SDA, GP15=SCL)
#define DISP_SDA_PIN 14
#define DISP_SCL_PIN 15

// VL53L1X em I2C1 (GP2=SDA, GP3=SCL)
#define MAX_SDA_PIN 2
#define MAX_SCL_PIN 3

// Pinos vindos do seu main.h para facilitar a leitura
#ifndef BUTTON5_PIN
#define BUTTON5_PIN 5
#endif

#ifndef LED_PIN_B
#define LED_PIN_B 12
#endif

// --- Variáveis Globais (Definição Real) ---
bool alarme = false;
bool posicao_js = false;
bool ledverdestatus = false;
MQTT_CLIENT_T *mqtt_state;
QueueHandle_t filaMQTT;
TaskHandle_t hTarefaSensor = NULL;
TaskHandle_t hTarefaMQTT = NULL;
bool tarefas_pausadas = false;

// Estrutura para a Fila de Dados do Sensor
typedef struct
{
    float temperatura;
    uint32_t pressao;
    uint16_t distancia_mm;
} DadosSensor;

// --- FUNÇÕES DE SUPORTE (Vindas do embarca.c e mqtt_utils.c) ---
static inline void i2c1_use_display_pins(void)
{
    // Ativa pinos do display (GP14/GP15)
    gpio_set_function(DISP_SDA_PIN, GPIO_FUNC_I2C);
    gpio_set_function(DISP_SCL_PIN, GPIO_FUNC_I2C);
    gpio_pull_up(DISP_SDA_PIN);
    gpio_pull_up(DISP_SCL_PIN);
    // Velocidade maior para o display
    i2c_set_baudrate(i2c1, 400000);
    sleep_ms(2);

    // Desativa pinos do sensor (GP2/GP3) para evitar conflito no barramento
    gpio_set_function(MAX_SDA_PIN, GPIO_FUNC_NULL);
    gpio_set_function(MAX_SCL_PIN, GPIO_FUNC_NULL);
    gpio_disable_pulls(MAX_SDA_PIN);
    gpio_disable_pulls(MAX_SCL_PIN);
}

static inline void i2c1_use_sensor_pins(void)
{
    // Ativa pinos do sensor (GP2/GP3)
    gpio_set_function(MAX_SDA_PIN, GPIO_FUNC_I2C);
    gpio_set_function(MAX_SCL_PIN, GPIO_FUNC_I2C);
    gpio_pull_up(MAX_SDA_PIN);
    gpio_pull_up(MAX_SCL_PIN);
    // Reduz velocidade para dar margem caso pull-ups sejam fracos
    i2c_set_baudrate(i2c1, 100000);
    sleep_ms(2);

    // Desativa pinos do display (GP14/GP15)
    gpio_set_function(DISP_SDA_PIN, GPIO_FUNC_NULL);
    gpio_set_function(DISP_SCL_PIN, GPIO_FUNC_NULL);
    gpio_disable_pulls(DISP_SDA_PIN);
    gpio_disable_pulls(DISP_SCL_PIN);
}

static void i2c_scan_bus(i2c_inst_t *i2c, const char *label)
{
    printf("[I2C] Scan %s:", label);
    for (int addr = 0x03; addr <= 0x77; addr++)
    {
        uint8_t dummy;
        int ret = i2c_read_timeout_us(i2c, addr, &dummy, 1, false, 2000);
        if (ret == 1)
        {
            printf(" 0x%02X", addr);
        }
    }
    printf("\n");
}

// Tentativa de detecção rápida para TCS34725 (endereço 0x29)
static bool tcs34725_read_id(i2c_inst_t *i2c, uint8_t addr, uint8_t *out_id)
{
    // Bit de comando 0x80 precisa ser somado ao registrador para leitura
    uint8_t reg = 0x80 | 0x12; // ID register
    int wr = i2c_write_blocking(i2c, addr, &reg, 1, true);
    if (wr != 1) return false;
    int rd = i2c_read_blocking(i2c, addr, out_id, 1, false);
    return rd == 1;
}

void pinos_start()
{
    gpio_init(BUTTON5_PIN);
    gpio_set_dir(BUTTON5_PIN, GPIO_IN);
    gpio_pull_up(BUTTON5_PIN);

    // Botão extra para pausar/retomar tarefas
    gpio_init(BUTTON6_PIN);
    gpio_set_dir(BUTTON6_PIN, GPIO_IN);
    gpio_pull_up(BUTTON6_PIN);

    // Inicializa LED RGB para PWM
    gpio_set_function(LED_PIN_B, GPIO_FUNC_PWM);
    gpio_set_function(LED_PIN_G, GPIO_FUNC_PWM);
    gpio_set_function(LED_PIN_R, GPIO_FUNC_PWM);

    pwm_config config = pwm_get_default_config();
    uint slice_b = pwm_gpio_to_slice_num(LED_PIN_B);
    uint slice_g = pwm_gpio_to_slice_num(LED_PIN_G);
    uint slice_r = pwm_gpio_to_slice_num(LED_PIN_R);
    pwm_init(slice_b, &config, true);
    pwm_init(slice_g, &config, true);
    pwm_init(slice_r, &config, true);
}

void pwm_led(uint gpio_pin, uint brilho)
{
    pwm_set_gpio_level(gpio_pin, brilho);
}

// Callback do DNS
static void dns_found(const char *name, const ip_addr_t *ipaddr, void *callback_arg)
{
    MQTT_CLIENT_T *state = (MQTT_CLIENT_T *)callback_arg;
    if (ipaddr)
    {
        state->remote_addr = *ipaddr;
        printf("[DNS] Resolvido: %s\n", ip4addr_ntoa(ipaddr));
    }
}

void run_dns_lookup(MQTT_CLIENT_T *state)
{
    printf("[DNS] Resolvendo %s...\n", MQTT_SERVER_HOST);
    cyw43_arch_lwip_begin();
    dns_gethostbyname(MQTT_SERVER_HOST, &(state->remote_addr), dns_found, state);
    cyw43_arch_lwip_end();

    // Aguarda resolução básica (em um sistema real, use semáforo)
    while (state->remote_addr.addr == 0)
    {
        vTaskDelay(pdMS_TO_TICKS(100));
    }
}

// --- CALLBACKS MQTT ---

static void mqtt_connection_cb(mqtt_client_t *client, void *arg, mqtt_connection_status_t status)
{
    if (status == MQTT_CONNECT_ACCEPTED)
    {
        printf("[MQTT] Conectado ao Broker!\n");
        // Subscreve ao tópico de comando
        mqtt_sub_unsub(client, "pico_w/recv", 0, NULL, NULL, 1);
    }
    else
    {
        printf("[MQTT] Erro na conexão: %d\n", status);
    }
}

static void mqtt_pub_data_cb(void *arg, const u8_t *data, u16_t len, u8_t flags)
{
    char buffer[BUFFER_SIZE];
    if (len < BUFFER_SIZE)
    {
        memcpy(buffer, data, len);
        buffer[len] = '\0';
        if (strcmp(buffer, "acender") == 0)
            pwm_led(LED_PIN_B, 3000);
        else if (strcmp(buffer, "apagar") == 0)
            pwm_led(LED_PIN_B, 0);
    }
}

// --- TAREFAS FREERTOS ---

void tarefaLeituraBotao(void *pvParameters)
{
    int estadoAnterior = 1;        // BUTTON5
    int estadoAnterior6 = 1;       // BUTTON6
    while (1)
    {
        int estado = gpio_get(BUTTON5_PIN);
        if (estado == 0 && estadoAnterior == 1)
        {
            ledverdestatus = !ledverdestatus;
            // Controle direto do LED sem semáforo/tarefa dedicada
            if (ledverdestatus) {
                pwm_led(LED_PIN_B, 2000);
            } else {
                pwm_led(LED_PIN_B, 0);
            }
        }
        estadoAnterior = estado;

        // Pausar/retomar tarefas (BUTTON6)
        int estado6 = gpio_get(BUTTON6_PIN);
        if (estado6 == 0 && estadoAnterior6 == 1)
        {
            if (!tarefas_pausadas) {
                if (hTarefaSensor) vTaskSuspend(hTarefaSensor);
                if (hTarefaMQTT) vTaskSuspend(hTarefaMQTT);
                tarefas_pausadas = true;
                printf("[Controle] Tarefas pausadas (Sensor, MQTT).\n");
                // Feedback visual opcional
                pwm_led(LED_PIN_B, 0);
            } else {
                if (hTarefaSensor) vTaskResume(hTarefaSensor);
                if (hTarefaMQTT) vTaskResume(hTarefaMQTT);
                tarefas_pausadas = false;
                printf("[Controle] Tarefas retomadas (Sensor, MQTT).\n");
                // Feedback visual opcional
                pwm_led(LED_PIN_B, 2000);
            }
        }
        estadoAnterior6 = estado6;
        vTaskDelay(pdMS_TO_TICKS(50));
    }
}


void tarefaSensorBMP280(void *pvParameters)
{
    // Inicializa I2C0 com os pinos definidos acima
    i2c_init(i2c0, 100 * 1000);
    gpio_set_function(I2C_SDA_PIN, GPIO_FUNC_I2C);
    gpio_set_function(I2C_SCL_PIN, GPIO_FUNC_I2C);
    gpio_pull_up(I2C_SDA_PIN);
    gpio_pull_up(I2C_SCL_PIN);

    // Inicializa I2C1 para o display
    i2c1_use_display_pins();
    ssd1306_init(i2c1, 0x3C);
    i2c_scan_bus(i2c1, "I2C1 GP14/GP15 (display)");

    // Inicializa sensor ToF (tenta VL53L0X primeiro; se falhar, usa VL53L1X)
    i2c1_use_sensor_pins();
    i2c_scan_bus(i2c1, "I2C1 GP2/GP3 (sensor)");
    bool use_l0x = false;
    bool tof_ok = false;
    if (vl53l0x_init(i2c1)) {
        use_l0x = true;
        tof_ok = true;
        printf("[VL53L0X] Sensor detectado e pronto.\n");
    } else {
        // Tenta VL53L1X como fallback
        tof_ok = vl53l1x_init(i2c1, VL53L1X_I2C_ADDR) &&
                 vl53l1x_start_continuous(i2c1, VL53L1X_I2C_ADDR, 50);
        if (tof_ok) {
            bool ready = false;
            for (int tries = 0; tries < 20 && !ready; ++tries) {
                sleep_ms(20);
                ready = vl53l1x_data_ready(i2c1, VL53L1X_I2C_ADDR);
            }
            printf("[VL53L1X] Inicializado e medindo continuamente. Pronto=%s\n", ready ? "sim" : "não");
        } else {
            printf("[ToF] Falha ao inicializar (confira fiação/pulls em GP2/GP3).\n");
        }
    }
    // Volta p/ pinos do display por padrão
    i2c1_use_display_pins();

    bmp280_init();
    DadosSensor dados;

    static const uint8_t epd_bitmap_fogo[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcf, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x8f, 0xff, 
	0xff, 0xe0, 0x7f, 0xbf, 0xcf, 0x80, 0x78, 0xfe, 0x60, 0x01, 0x80, 0x3f, 0xff, 0xff, 0x9f, 0xff, 
	0xff, 0x80, 0x1f, 0x9f, 0xcf, 0x80, 0xf8, 0x7e, 0x70, 0x03, 0x80, 0x7f, 0xff, 0xff, 0xbf, 0xff, 
	0xff, 0x1f, 0x8f, 0x9f, 0xcf, 0x9f, 0xf8, 0x7e, 0x7f, 0x3f, 0x9f, 0xff, 0xff, 0xff, 0x7f, 0xff, 
	0xff, 0x3f, 0xcf, 0x9f, 0xcf, 0x9f, 0xf8, 0x3e, 0x7f, 0x3f, 0x9f, 0xff, 0xff, 0xfe, 0xff, 0xff, 
	0xfe, 0x3f, 0xcf, 0x9f, 0xcf, 0x9f, 0xf9, 0x3e, 0x7f, 0x3f, 0x9f, 0xff, 0xff, 0xfd, 0xff, 0xff, 
	0xfe, 0x7f, 0xc7, 0x9f, 0xcf, 0x9f, 0xf9, 0x9e, 0x7f, 0x3f, 0x9f, 0xff, 0xff, 0xfd, 0xff, 0xff, 
	0xfe, 0x7f, 0xe7, 0x9f, 0xcf, 0x9f, 0xf9, 0x8e, 0x7f, 0x3f, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xfe, 0x7f, 0xe7, 0x9f, 0xcf, 0x80, 0xf9, 0xce, 0x7f, 0x3f, 0x80, 0x7f, 0xff, 0xff, 0xff, 0xff, 
	0xfe, 0x7f, 0xe7, 0x9f, 0xcf, 0x8f, 0xf9, 0xc6, 0x7f, 0x3f, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xfe, 0x7f, 0xc7, 0x9f, 0xcf, 0x9f, 0xf9, 0xe6, 0x7f, 0x3f, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xfe, 0x7f, 0xcf, 0x9f, 0xcf, 0x9f, 0xf9, 0xf2, 0x7f, 0x3f, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xfe, 0x3f, 0xcf, 0x9f, 0xcf, 0x9f, 0xf9, 0xf0, 0x7f, 0x3f, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0x1f, 0x9f, 0x8f, 0x8f, 0x9f, 0xf9, 0xf8, 0x7f, 0x3f, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0x84, 0x1f, 0xc2, 0x1f, 0x8f, 0xf9, 0xf8, 0x7f, 0x3f, 0x8f, 0xff, 0xff, 0xef, 0xff, 0xff, 
	0xff, 0xc0, 0x07, 0xe0, 0x7f, 0x80, 0x79, 0xfc, 0x7f, 0x3f, 0x80, 0x3f, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    // 'gelo', 110x110px
    static const uint8_t epd_bitmap_gelo[] = {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xff, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0x87, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x9f,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xbf, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xf9, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xfe, 0x7f, 0xff,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xff, 0xfc, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xff, 0xfc, 0xff, 0xff, 0x7f, 0xfd, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xfe, 0xff, 0xfb, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,

        0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xbe, 0xff, 0xff,

        0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xff, 0x1e, 0xff, 0xff, 0xff, 0xfc,

        0xff, 0xff, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xbe, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff,

        0xfe, 0xff, 0xf7, 0xff, 0xfc, 0xff, 0xff, 0xbe, 0xfd, 0xff, 0xff, 0xfc, 0xff, 0xff, 0x00, 0x7f,

        0xf7, 0xff, 0xff, 0xff, 0xff, 0xbe, 0xf8, 0x01, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xff,

        0xff, 0xff, 0xff, 0xbe, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xe1, 0xff, 0xfe,

        0x1f, 0xbe, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xc7, 0xff, 0xff, 0x8f, 0xbe,

        0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xbe, 0xff, 0xff,

        0xff, 0xfc, 0xff, 0xff, 0xff, 0xf9, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xbe, 0x7f, 0xff, 0xff, 0xfc,

        0xff, 0xff, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xbf, 0xbf, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff,

        0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff,

        0xf7, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xfd, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff,

        0xff, 0xbf, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xfb, 0xff, 0xe7, 0xff, 0xff, 0xff, 0xff, 0x9f,

        0xff, 0x7f, 0xff, 0xfc, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,

        0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xfc,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff,

        0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xfe, 0x7f, 0xe7, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xff, 0x9f, 0xf1, 0xff, 0xfc, 0xff, 0xfe, 0x7f, 0xe0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfb,

        0x1f, 0xf1, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xff,

        0xff, 0xfc, 0xff, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xef, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xfc, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xfc, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xff, 0x3f, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xfc, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd,

        0xff, 0x9c, 0xe6, 0x3c, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xfc, 0xfc, 0x1c,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xfc, 0xff, 0xf3,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xfc, 0xff, 0xe7, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xfc, 0xff, 0xef, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xfc, 0xff, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,

        0xff, 0xff, 0xff, 0xe7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xfc, 0xff, 0xfe,

        0x3f, 0xe7, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0x9f, 0xf1, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xef,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff,

        0xf9, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xfb, 0xff,

        0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xfc, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xfc,

        0xff, 0xff, 0xf1, 0xfe, 0x47, 0xff, 0xff, 0xff, 0xff, 0x8f, 0xf0, 0x3f, 0xff, 0xfc, 0xff, 0xff,

        0xfb, 0xff, 0xe7, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xff, 0x7f, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff,

        0xf7, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xff,

        0xfd, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xf7, 0xff, 0xff,

        0xbf, 0xbf, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xf3, 0xff, 0xfe, 0x3f, 0xbf,

        0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xf9, 0xf7, 0xf7, 0xff, 0xff, 0xbf, 0xbe, 0x7f, 0xff,

        0xff, 0xfc, 0xff, 0xff, 0xff, 0xfb, 0xf7, 0xf7, 0xff, 0xff, 0xbf, 0xbe, 0x7f, 0xff, 0xff, 0xfc,

        0xff, 0xff, 0xff, 0xff, 0xf7, 0xc7, 0xff, 0xff, 0x8f, 0xbe, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff,

        0xff, 0xfd, 0xf7, 0xe1, 0xff, 0xfe, 0x1f, 0xbe, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xfd,

        0xf7, 0xff, 0xff, 0xff, 0xff, 0xbe, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xfe, 0x00, 0x7d, 0xf7, 0xff,

        0xfd, 0xff, 0xff, 0xbe, 0xf8, 0x01, 0xff, 0xfc, 0xff, 0xff, 0xfe, 0xff, 0xf7, 0xff, 0xfc, 0xff,

        0xff, 0xbe, 0xfc, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xbe,

        0xfd, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xff, 0x1e, 0xff, 0xff,

        0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xbe, 0xff, 0xff, 0xff, 0xfc,

        0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff,

        0xff, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xfe, 0x7f, 0xff,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xff, 0xfc, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xff,

        0xff, 0xff, 0x7f, 0xff, 0xff, 0xf9, 0xff, 0xfc, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xf1, 0xff, 0xfe,

        0x7f, 0xff, 0xff, 0xfb, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0xff, 0xfe, 0x7f, 0xff,

        0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xff, 0xc7, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xff, 0x87, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xdf, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

        0xff, 0xff, 0xff, 0xfc};

    while (1)
    {
        // Lê distância do sensor ToF (VL53L0X ou VL53L1X) nos pinos GP2/GP3
        uint16_t dist_mm = 0;
        uint8_t range_status = 0, stream_count = 0;
        i2c1_use_sensor_pins();
        if (tof_ok) {
            if (use_l0x) {
                if (vl53l0x_read_distance_mm(i2c1, &dist_mm)) {
                    printf("[VL53L0X] Distância: %u mm\n", (unsigned)dist_mm);
                }
            } else {
                if (vl53l1x_read_range_block(i2c1, VL53L1X_I2C_ADDR, &dist_mm, &range_status, &stream_count)) {
                    printf("[VL53L1X] Distância: %u mm | status=0x%02X | stream=%u\n", (unsigned)dist_mm, range_status, stream_count);
                }
            }
        }
        // Retorna para os pinos do display
        i2c1_use_display_pins();

        sensors_t s = bmp280_get_all(I2C_ADDR);
        dados.temperatura = s.temperature;
        dados.pressao = s.pressure;
        dados.distancia_mm = dist_mm;

        printf("[Sensor] T: %.2f C | P: %lu Pa\n", dados.temperatura, dados.pressao);

        ssd1306_clear();

        const char *word = (dados.temperatura >= (float)TEMP_THRESHOLD_C) ? "QUENTE" : "FRIO";
        int len = (int)strlen(word);
        // Calcula escala máxima que cabe na largura e altura
        int max_scale_w = 128 / (len * 6);
        int max_scale_h = 64 / 7;
        int scale = max_scale_w;
        if (scale > max_scale_h) scale = max_scale_h;
        if (scale < 1) scale = 1;
        int text_w = len * 6 * scale;
        int text_h = 7 * scale;
        int x0 = (128 - text_w) / 2;
        int y0 = (64 - text_h) / 2;

        ssd1306_draw_text_scaled(x0, y0, word, scale, true);

        // LED cores: quente=vermelho, frio=azul
        if (dados.temperatura >= (float)TEMP_THRESHOLD_C) {
            pwm_led(LED_PIN_R, 3000);
            pwm_led(LED_PIN_G, 0);
            pwm_led(LED_PIN_B, 0);
        } else {
            pwm_led(LED_PIN_R, 0);
            pwm_led(LED_PIN_G, 0);
            pwm_led(LED_PIN_B, 3000);
        }

        ssd1306_update();

        xQueueSend(filaMQTT, &dados, 0);
        vTaskDelay(pdMS_TO_TICKS(10000));
    }
}

void tarefaMQTT(void *pvParameters)
{
    // 1. Inicializa o Wi-Fi SOMENTE AQUI dentro do RTOS
    if (cyw43_arch_init())
    {
        printf("[Erro] Falha no hardware Wi-Fi\n");
        vTaskDelete(NULL);
    }
    cyw43_arch_enable_sta_mode();

    printf("[Wi-Fi] Conectando a %s...\n", WIFI_SSID);
    while (cyw43_arch_wifi_connect_timeout_ms(WIFI_SSID, WIFI_PASSWORD, CYW43_AUTH_WPA2_AES_PSK, 15000))
    {
        printf("[Wi-Fi] Tentando reconectar...\n");
        vTaskDelay(pdMS_TO_TICKS(3000));
    }
    printf("[Wi-Fi] Online!\n");

    // 2. Evite calloc: Use uma variável estática para o estado
    static MQTT_CLIENT_T local_state;
    mqtt_state = &local_state;

    run_dns_lookup(mqtt_state);

    struct mqtt_connect_client_info_t ci = {0};
    ci.client_id = "PicoW_Pablo_ADS"; //
    ci.keep_alive = 60;

    cyw43_arch_lwip_begin();
    mqtt_state->mqtt_client = mqtt_client_new();
    mqtt_client_connect(mqtt_state->mqtt_client, &(mqtt_state->remote_addr), MQTT_SERVER_PORT, mqtt_connection_cb, mqtt_state, &ci);
    mqtt_set_inpub_callback(mqtt_state->mqtt_client, NULL, mqtt_pub_data_cb, NULL);
    cyw43_arch_lwip_end();

    DadosSensor dados;
    char payload[BUFFER_SIZE];

    while (1)
    {
        if (xQueueReceive(filaMQTT, &dados, portMAX_DELAY))
        {
            if (mqtt_client_is_connected(mqtt_state->mqtt_client))
            {
                snprintf(payload, BUFFER_SIZE,
                         "{\"temp\": %.2f, \"pres\": %lu, \"dist\": %u, \"threshold_mm\": %u, \"temp_threshold_c\": %.2f}",
                         dados.temperatura,
                         dados.pressao,
                         dados.distancia_mm,
                         (unsigned)DIST_THRESHOLD_MM,
                         (double)TEMP_THRESHOLD_C);
                cyw43_arch_lwip_begin();
                mqtt_publish(mqtt_state->mqtt_client, "pico_w/sensor", payload, strlen(payload), 0, 0, NULL, NULL);
                cyw43_arch_lwip_end();
                printf("[MQTT] Enviado: %s\n", payload);
            }
        }
    }
}

int main()
{
    stdio_init_all();

    int wait_ms = 5000;
    while (!stdio_usb_connected() && wait_ms > 0)
    {
        sleep_ms(100);
        wait_ms -= 100;
    }
    sleep_ms(200);

    printf("\n==================================\n");
    printf("SISTEMA BITDOGLAB: INICIANDO\n");
    printf("==================================\n");

    pinos_start();

    filaMQTT = xQueueCreate(5, sizeof(DadosSensor));

    // Valores otimizados para evitar estouro de memória
    xTaskCreate(tarefaLeituraBotao, "Botao", 128, NULL, 1, NULL);
    xTaskCreate(tarefaSensorBMP280, "Sensor", 256, NULL, 1, &hTarefaSensor);
    xTaskCreate(tarefaMQTT, "MQTT", 896, NULL, 1, &hTarefaMQTT); // Reduzido para 896

    vTaskStartScheduler();
    while (1)
        ;
}